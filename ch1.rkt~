#lang sicp

;; 1.1 The Element of Programming

;; ;; (+ 137 349)

;; ;; (define size 2)
;; ;; size

;; ;; define a function
;; (define (ab x)
;;   (cond ((> x 0) x)
;;         ((= x 0) 0)
;;         ((< x 0) (- x))))
;; (ab -100)
                 

;; (define (abss x)
;;   (if (< x 0) (- x)
;;       x))

;; (or (> 1 0) (= 2 1))

;; (not (< 1 0))

;; ;; (define (>= x y)
;; ;;   (not (< x y)))

;; ;; Exercise 1.1
;; (define a 3)
;; (define b (+ a 1))
;; (+ a b (* a b))
;; (= a b)
;; (if (and (> b a) (< b (* a b)))
;;     b
;;     a)
;; (cond ((= a 4) 6)
;;       ((= b 4) (+ 6 7 a))
;;       (else 25))
;; (+ 2 (if (> b a) b a))
;; (* (cond ((> a b) a)
;;          ((< a b) b)
;;          (else -1))
;;    (+ a 1))

;; ;; Exercise 1.2
;; (/ (+ 5 4
;;       (- 2
;;          (- 3
;;             (+ 6
;;                (/ 4 5)))))
;;    (* 3
;;       (- 6 2) (- 2 7)))

;; ;; Exercise 1.3
;; (define (>= x y) (not (< x y)))
;; (define (<= x y) (not (> x y)))
;; (define (squar x) (* x x))
;; (define (sum-of-squares x y) (+ (squar x) (squar y)))
;; (define (sum-of-squares-two-larger-numbers x y z)
;;   (cond ((and (>= x z) (>= y z)) (sum-of-squares x y))
;;         ((and (>= x y) (>= z y)) (sum-of-squares x z))
;;         ((and (>= y x) (>= z x)) (sum-of-squares y z))))
;; testing code for 1.3
;; (sum-of-squares-two-larger-numbers 1 2 3)
;; (sum-of-squares-two-larger-numbers 2 1 3)
;; (sum-of-squares-two-larger-numbers 3 2 1)
;; (sum-of-squares-two-larger-numbers 3 1 1)
;; (sum-of-squares-two-larger-numbers 1 1 3)
;; (sum-of-squares-two-larger-numbers 1 3 1)
;; (sum-of-squares-two-larger-numbers 3 3 1)
;; (sum-of-squares-two-larger-numbers 3 1 3)
;; (sum-of-squares-two-larger-numbers 1 3 3)

;; ;; Exercise 1.4
;; (define (a-plus-abs-b a b)
;;   ((if (> b 0) + -) a b))

;; Exercise 1.5
;; (define (p) (p))
;; (define (test x y)
;;   (if (= x 0)
;;       0
;;       y))

;; (test 0 (p))

;; 1.1.7 Square Roots by Newton's Method

;; (define (sq x)
;;   (* x x))

;; (define (sqrtt x)
  
;;   (define (sqrt-iter guess x)
;;     (if (good-enough? guess x)
;;       guess
;;       (sqrt-iter (improve guess x) x)))
  
;;   (define (sq x)
;;     (* x x))
  
;;   (define (good-enough? guess x)
;;   (<= (abs (- (improve guess x) guess))
;;       (* 0.0001 guess)))
  
;;   (define (average a b)
;;     (/ (+ a b) 2))

;;   (define (improve guess x)
;;     (average guess (/ x guess)))
  
;;     (sqrt-iter 1.0 x))

;; (sqrtt 0.0001) 

;; new-if 

;; (define (new-if predicate then-clause else-clause)
;;   (cond (predicate then-clause)
;;         (else else-clause)))



;; Exercise 1.8 Newton's Method for Cube Roots

;; (define (cube-iter guess x)
;;   (if (good-enough-cube? guess x)
;;      guess
;;      (cube-iter (improve guess x) x)))

;; (define (cube x) (* x x x))
;; (define (square x) (* x x))

;; (define (good-enough-cube? guess x)
;;   (<= (abs (- (cube guess) x)) 0.001))
;;   (<= (abs (- (sq guess) x)) 0.001))

;; (define (improve guess x)
;;   (/ (+ (/ x
;;            (* guess guess))
;;         (* 2 guess))
;;      3))

;; (cube-iter 1.0 -75)

;; 1.2 Procedures and the Process They Generate

;; 1.2.1 Linear Recursion and Iteration

;; (define (factorial n)
;;   (if (= n 1)
;;       1
;;       (* n (factorial (- n 1)))))

;; (factorial 6)

;; (define (fact-iter n)
;;   (define (factorial-iter counter product)
;;     (if (> counter n)
;;         product
;;         (factorial-iter (+ counter 1)
;;                         (* product counter))))
;;   (factorial-iter 1 1))

;; (fact-iter 6) 

;; Exercise 1.9

;; (define (inc x) (+ 1 x))
;; (define (dec x) (- 1 x))

;; (define (p a b)
;;   (if (= a 0)
;;       b
;;       (inc (p (dec a) b))))

;; (define (p a b)
;;   (if (= a 0)
;;       b
;;       (p (dec a) (inc b))))

;; (+ 4 5)

;; Exercise 1.10
;; (define (A x y)
;;   (cond ((= y 0) 0)
;;         ((= x 0) (* 2 y))
;;         ((= y 1) 2)
;;         (else (A (- x 1)
;;                  (A x (- y 1))))))

;; (A 1 10)
;; (A 2 4)
;; (A 3 3)

;; (define (h n) (A 2 n))
;; (h 3)

;; 1.2.2 Tree Recursion

;; (define (fib n)
;;   (cond ((= n 0) 0)
;;         ((= n 1) 1)
;;         (else (+ (fib (- n 2))
;;                  (fib (- n 1))))))
;; (fib 7)

;; (define (fib n)
;;   (define (fib-iter counter a b)
;;     (cond ((= n 0) 0)
;;           ((= n 1) 1)
;;           ((> counter n) b) 
;;           (else (fib-iter (+ counter 1) (+ a b) a))))
;;   (fib-iter 0 0 1))

;; Example Counting change

;; (define (count-change amount)
;;   (cc amount 5))

;; (define (cc amount kinds-of-coins)
;;   (cond ((= amount 0) 1)
;;         ((or (< amount 0)
;;             (= kinds-of-coins 0))
;;           0)
;;         (else
;;          (+ (cc amount (- kinds-of-coins 1))
;;              (cc (- amount
;;                     (first-denomination kinds-of-coins))
;;                  kinds-of-coins)))))

;; (define (first-denomination kinds-of-coins)
;;   (cond ((= kinds-of-coins 1) 1)
;;         ((= kinds-of-coins 2) 5)
;;         ((= kinds-of-coins 3) 10)
;;         ((= kinds-of-coins 4) 25)
;;         ((= kinds-of-coins 5) 50)))

;; (count-change )

;; Exercise 1.11

;; (define (f n)
;;   (if (< n 3)
;;       n
;;       (+ (f (- n 1))
;;          (* 2 (f (- n 2)))
;;          (* 3 (f (- n 3))))))

;; (define (f n)
  
;;   (define (f-iter counter a b c)
;;     (cond ((< n 3) n)
;;           ((not (< counter n)) a)
;;           (else
;;            (f-iter (+ counter 1)
;;                    (+ a (* b 2) (* c 3))
;;                    a
;;                    b))))
  
;;   (f-iter 2 2 1 0))

         
;; Exercise 1.12

;; (define (pascal row col)
;;   (cond ((or (= col 1)
;;              (= col row))
;;          1)
;;         (else (+ (pascal (- row 1) (- col 1))
;;                  (pascal (- row 1) col)))))

;; (define (pascal row col)
  
;;   (define (pascal-iter counter row col)
;;     (cond ((or
;;             (= col row)
;;             (= col 1))
;;            1)
;;           ()

;;           )

;;   (pascal-iter 1 row col))


;; Exerise 1.13

;; 1.2.3 Orders of Growth

;; 1.2.4 Exponentiation

;; recursive process
;; (define (expo b n)
;;   (if (= n 0)
;;       1
;;       (* b (expo b (- n 1)))))

;; ;; iterative process
;; (define (expo b n)
  
;;   (define (expo-iter counter product)
;;     (if (= counter n)
;;         product
;;         (expo-iter (+ counter 1) (* product b))))
    
;;   (expo-iter 0 1))

;; another way to do iterative process
;; (define (expo b n)
  
;;   (define (expo-iter counter product)
;;     (if (= counter 0)
;;         product
;;         (expo-iter (- counter 1) (* product b))))
  
;;   (expo-iter n 1))
;; (define (square x)
;;   (* x x))

;; (define (fast-expo b n)
;;   (cond ((= n 0) 1)
;;         ((is-even n)
;;          (square (fast-expo b (/ n 2))))
;;         (else
;;           (* b (fast-expo b (- n 1))))))

;; (define (is-even n)
;;   (= (remainder n 2) 0))

;; (define (super-fast-expo b n)
  
;;   (define (iter b product counter)
;;     (cond ((= counter 0) product)
;;           ((is-even counter)
;;            (iter (square b) product (/ counter 2)))
;;           (else (iter b (* product b) (- counter 1)))))

;;   (iter b 1 n))

;; (super-fast-expo 3 3)

;; Exercise 1.17

;; (define (* a b)
;;   (if (= b 0)
;;       0
;;       (+ a (* a  (- b 1)))))

;; (define (double x)
;;   (+ x x))

;; recucursive process (logrithmatic number of steps)
;; (define (fast-mul a b)
;;   (cond ((= a 0) 0)
;;         ((= a 1) b)
;;         ((is-even a) (fast-mul (/ a 2) (double b)))
;;         (else (+ b
;;                  (fast-mul (- a 1) b)))))

;; iterative process

;; (define (iter-mul a b)

;;   (define (is-even n)
;;     (= (remainder n 2) 0))

;;   (define (double n)
;;     (+ n n))

;;   (define (iter counter sum mut)
;;     (cond ((= a 0) 0)
;;           ((= counter 0) mut)
;;           ((is-even counter)
;;            (iter (/ counter 2) (double sum) mut))
;;           (else (iter (- counter 1) sum (+ sum b)))))
  
;;   (iter a b 0))

;; (iter-mul 2 2)
 
